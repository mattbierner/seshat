/**
 * @fileOverview Memoization utility.
 */
static define;
define([],
function() {
//"use strict";

var max = \x, y -> (x > y ? x : y);

var height = \root ->
    (!root ? 0 :
        max(
            (root.left ? 1 + root.left.height : 0),
            (root.right ? 1 + root.right.height : 0)));

/* Data Structures
 ******************************************************************************/
// Cell
////////////////////////////////////////
/**
 * Memoization cell
 * 
 * Stores a value for a given id. Cells form a linked list.
 */
var Cell = function(id, val, delegate) {
    this.id = id;
    this.val = val;
    this.delegate = delegate;
};

/**
 * Lookup a value, if any, stored in a match cell for 'state'.
 */
Cell.lookup = \base, id -> {
    for (var cell = base; cell; cell = cell.delegate)
        if (cell.id === id)
            return cell.val;
    return null;
};

// Node
////////////////////////////////////////
/**
 * 
 */
var Node = function(key, cell, l, r, height) {
    this.key = key;
    this.cell = cell;
    this.left = l;
    this.right = r;
    this.height = height;
};

Node.setChildren = \node, l, r ->
    new Node(
        node.key,
        node.cell,
        l,
        r,
        1 + max(height(l), height(r)));

Node.setLeft = \node, l ->
    Node.setChildren(node, l, node.right);
    
Node.setRight = \node, r ->
    Node.setChildren(node, node.left, r);

/* Tree Operations
 ******************************************************************************/
/**
 */
Node.lookup = \root, compare, key, id -> {
    for (var node = root; node;) {
        var diff = compare(key, node.key);
        if (diff === 0)
            return Cell.lookup(node.cell, id);
        node = (diff < 0 ? node.left : node.right);
    }
    return null;
};

/**
 */
Node.put = \node, id, val ->
    new Node(
        node.key,
        new Cell(
            id,
            val,
            node.cell),
        node.left,
        node.right,
        node.height);

/**
 * 
 */
var rr = \node -> 
    (!node ? node :
        Node.setLeft(
            node.right,
            Node.setRight(
                node,
                node.right.left)));
/**
 * 
 */
var ll = \node ->
    (!node ? node :
        Node.setRight(
            node.left,
            Node.setLeft(
                node,
                node.left.right)));

var lr = \node ->
    ll(Node.setLeft(node, rr(node.left)));

var rl = \node ->
    rr(Node.setRight(node, ll(node.right)));

var df = \node ->
    (!node ? 0 :
        (node.left ? 1 + height(node.left) : 0) - (node.right ? 1 + height(node.right): 0));

/**
 */
Node.update = \root, compare, pos, id, val -> {
    if (!root)
        return new Node(pos, new Cell(id, val, null), null, null, 0);
    
    var diff = compare(pos, root.key);
    if (diff === 0)
        return Node.put(root, id, val);
    
    var node = (diff < 0 ?
        Node.setLeft(root, Node.update(root.left, compare, pos, id, val)) :
        Node.setRight(root, Node.update(root.right, compare, pos, id, val)));
    
    var d = df(node);
    if (d > 1)
        return df(node.left) <= -1 ? lr(node) : ll(node);
    else if (d < -1) 
        return df(node.right) >= 1 ? rl(node) : rr(node);
    return node;
};

/**
 * 
 */
Node.rebalance = \root -> {
    var d = df(root);
    if (d > 1 || d < -1) {
        var node = Node.setChildren(root, Node.rebalance(root.left), Node.rebalance(root.right));
        var d = df(node);
        if (d > 1)
            return (df(node.left) <= -1 ? lr(node) : ll(node));
        else if (d < -1) 
            return (df(node.right) >= 1 ? rl(node) : rr(node));
    }
    return root;
};

/**
 */
Node.prune =  \root, compare, lower, upper -> {
    if (!root)
        return root;
    
    if (lower !== undefined ) {
        var dl = compare(root.key, lower);
        if (dl < 0)
            return Node.prune(root.right, compare, lower, upper);
        else if (dl === 0)
            return Node.setChildren(root, null, Node.prune(root.right, compare, undefined, upper));
    }
    
    if (upper !== undefined && compare(root.key, upper) >= 0)
        return Node.prune(root.left, compare, lower, upper);
   
    return Node.setChildren(
        root,
        Node.prune(root.left, compare, lower, upper),
        Node.prune(root.right, compare, lower, upper));
};

/* Memoer
 ******************************************************************************/
/**
 * Stores values by a comparable key and unique id.
 * 
 * @param compare Function that compares two keys, returning their relative order.
 * @param root Root of the tree.
 */
var Memoer = function(compare, root) {
    this.compare = compare;
    this.root = root;
};

/**
 */
Memoer.setRoot = \m, root ->
    new Memoer(
        m.compare,
        root);

/* Operations
 ******************************************************************************/
var create = \compare ->
    new Memoer(
        compare,
        null,
        []);

/**
 * Lookup a value, if any, stored in a match cell for 'state'.
 */
var lookup = \m, key, id ->
    Node.lookup(
        m.root,
        m.compare,
        key,
        id);

/**
 */
var update = \m, pos, id, val ->
    Memoer.setRoot(
        m,
        Node.update(m.root, m.compare, pos, id, val));

/**
 * 
 */
var prune = \m, lower, upper ->
    Memoer.setRoot(
        m,
        Node.rebalance(Node.prune(
            m.root,
            m.compare,
            lower,
            upper)));

/* Export
 ******************************************************************************/
return {
    'create': create,
    'lookup': lookup,
    'update': update,
    'prune': prune
};

});